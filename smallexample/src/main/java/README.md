

- [java 运行时数据区](#java-运行时数据区域)
    - [程序计数器](#程序计数器)
    - [java虚拟机栈](#java虚拟机栈)
    - [本地方法栈](#本地方法栈)
    - [java堆](#java堆)
    - [方法区](#方法区)
    - [运行时常量池](#运行时常量池)
    - [直接内存](#直接内存)
    

    


## java-运行时数据区域

JAVA 虚拟机定义了若干种程序运行期间会使用到的运行时数据区,其中有一些会随着虚拟机启动而创建,随着虚拟机退出而销毁.另外一些则是与线程一一对应的,这些与线程对应的数据区域会随着线程开始和结束而创建和销毁.

 <strong>java 虚拟机运行时数据区</strong>
 
![](https://www.pushtechnology.com/wp-content/uploads/2017/11/JVM_memory_model.png)

---
### 程序计数器

   程序计数器(Program Counter registers),即图中PC registers区域.
    
   java虚拟机中唯一一个没有规定任何`OutOfMemoryError`情况的区域.每一条java虚拟机线程都有自己的程序计数器.在任意时刻,一条java虚拟机线程只会执行一个方法的代码,正在被线程执行的方法称为该线程的当前方法.如果当线程的当前方法不是`native`方法,则程序计数器就保存Java虚拟机正在执行的字节码指令的地址,否则,程序计数器的值为undefined.
    
   由于程序计数器是每一个线程私有的部分,所以这部分区域 属于线程安全区.

### java虚拟机栈
    
   java虚拟机栈(Java Virtual Machine Stack),即图中 Thread stacks区域.

   java虚拟机栈和程序计数器一样,属于线程安全区域.这个栈与线程同时创建,用于存储栈帧,该栈帧用于存储局部变量表,操作数栈,动态链接,方法出口等信息,每一个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机中入栈到出栈的过程.因为除了栈帧的的出栈和入栈之外,java虚拟机栈不会受其他因素的影响,所以栈帧可以在堆中分配,从而java虚拟机栈所使用的内存不需要保证是连续的.
    
   java虚拟机规范既允许java虚拟机栈被实现成固定大小,也允许根据计算动态来扩展和收缩.如果采用固定大小的java虚拟机栈,那么每一个线程的java虚拟机栈容量可以在创建的时候独立选定.
    
   java虚拟机规范中定义了java虚拟机栈可能发生如下异常情况:
    
    * 如果线程请求分配的栈容量超过java虚拟机允许的最大容量,java虚拟机将会抛出一个`StackOverflowError`错误.
    * 如果java虚拟机栈可以动态扩展,并且在尝试扩展的时候无法申请到足够的内存,或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈,那么java虚拟机将会抛出一个`OutOfMemoryError`错误
    
### 本地方法栈

   本地方法栈(Native Method Stack),即图中 Native methods stack区域.

   java虚拟机的实现可能会使用到传统的栈(如 C Stack)来支持`native`方法,的执行,这个栈就是本地方法栈.其与java虚拟机栈不同的地方在于:java虚拟机栈为虚拟机执行java方法服务,而本地方法栈则为虚拟机执行Native服务.
    
   其异常情况,和java虚拟机栈的情况相同.
    
   本地方法栈也属于线程安全区域.
   
### java堆
 
   java堆(Java Heap),即图中 Heap 区域.

   java堆是可供各个线程共享的运行时内存区域(线程不安全),也是供所有的类实例和数组对象分配内存的区域.
    
   java堆在虚拟机创建的时候被创建,它存储了被自动内存管理系统所管理的各种对象.这些对象无需也无法显示的销毁.java堆的容量是可以固定的,也可以随着程序执行的需求进行动态扩展.java堆所使用的内存不需要保证是连续的.
    
   如果实际所需的堆超过了自动内存管理系统所能提供的最大容量,那么java虚拟机将会抛出一个`OutOfMemoryError`错误.
 
### 方法区
    
   方法区(Method area),即图中 Method area区域.

   方法区是可供各个线程共享的运行时内存区域.它被用于存储被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等.
    
   方法区在虚拟机启动的时候进行创建,虽然方法区是堆的逻辑组成部分,但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩.这个区域内存回收目标主要是针对常量池的回收和对类型的卸载.
    
   根据虚拟机规范,若该区域的内存空间不能满足内存分配请求时,java虚拟机将会抛出一个`OutOfMemoryError`错误

### 运行时常量池

   运行时常量池(runtime constant pool),即图中 Run-time constant pool 区域.

   运行时常量池是方法区的一部分,是class文件中每一个类或接口的常量池表的运行时表示形式,它包含了若干种不同的常量,从编译器可知的数值字面量到必须在运行期解析后才能获得的方法或字段引用.
    
   运行时常量池是方法区的一部分,受到方法区内存的限制,当其所需的内存空间超过了方法区所能提供的最大值,那么虚拟机将会抛出一个`OutOfMemoryError`
    
   该区域不不属于线程安全区域.

### 直接内存

   直接内存(Direct Memory)

   不属于虚拟机运行时数据区的一部分,也不是java虚拟机规范中定义的内存区域.但是这部分内存也被频繁使用,而且也可能导致`OufOfMemoryError`错误.
    
   NIO引入了基于通道(Channel)与缓冲区(Buffer)de I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆中的`DirectByBuffer`对象作为这块内存的引用进行操作.这样能在一些场景中显著提高性能,因为避免了在java和Native堆中来回复制数据.
    
   本机直接内存不会受Java堆大小的限制,而既然是内存,肯定还是受本机总内存大小以及处理器寻址空间的限制.这部分区域在无法获得新的内存分配时,出现`OutOfMemoryError`错误.
    
综上,当程序出现`OutOfMemoryError`时,需要考虑出现问题的区域,除了[程序计数器](#程序计数器)之外，都需要考虑一下下。。。
    
    
    
 